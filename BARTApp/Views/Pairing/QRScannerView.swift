import SwiftUI
import AVFoundation
import AudioToolbox

struct QRScannerView: View {
    @Environment(\.dismiss) private var dismiss
    @State private var scannedCode: String?
    @State private var error: QRPairingError?
    @State private var isProcessing = false

    let onScanned: (QRPairingPayload) -> Void

    var body: some View {
        ZStack {
            QRScannerRepresentable(
                onCodeScanned: handleScannedCode,
                onError: { error = $0 }
            )
            .ignoresSafeArea()

            // Scanning overlay
            VStack {
                HStack {
                    Button(action: { dismiss() }) {
                        Image(systemName: "xmark.circle.fill")
                            .font(.title)
                            .foregroundStyle(.white)
                            .shadow(radius: 2)
                    }
                    Spacer()
                }
                .padding()

                Spacer()

                // Scanning frame
                RoundedRectangle(cornerRadius: 20)
                    .strokeBorder(Color.white, lineWidth: 3)
                    .frame(width: 250, height: 250)
                    .overlay {
                        if isProcessing {
                            ProgressView()
                                .tint(.white)
                                .scaleEffect(1.5)
                        }
                    }

                Spacer()

                VStack(spacing: 12) {
                    Text("Scan QR Code")
                        .font(.title2.bold())
                        .foregroundStyle(.white)

                    Text("Point your camera at the QR code\ngenerated by `openclaw devices pair --qr`")
                        .font(.subheadline)
                        .foregroundStyle(.white.opacity(0.8))
                        .multilineTextAlignment(.center)
                }
                .padding(.bottom, 60)
            }
        }
        .alert("Scanning Error", isPresented: .init(
            get: { error != nil },
            set: { if !$0 { error = nil } }
        )) {
            Button("Try Again") {
                error = nil
            }
            Button("Cancel", role: .cancel) {
                dismiss()
            }
        } message: {
            Text(error?.localizedDescription ?? "Unknown error")
        }
    }

    private func handleScannedCode(_ code: String) {
        guard !isProcessing else { return }
        isProcessing = true

        do {
            let payload = try QRPairingPayload.decode(from: code)

            if payload.isExpired {
                error = .expired
                isProcessing = false
                return
            }

            // Haptic feedback on success
            let generator = UINotificationFeedbackGenerator()
            generator.notificationOccurred(.success)

            onScanned(payload)
            dismiss()
        } catch {
            self.error = .invalidJSON
            isProcessing = false
        }
    }
}

// MARK: - AVFoundation Scanner

struct QRScannerRepresentable: UIViewControllerRepresentable {
    let onCodeScanned: (String) -> Void
    let onError: (QRPairingError) -> Void

    func makeUIViewController(context: Context) -> QRScannerViewController {
        let controller = QRScannerViewController()
        controller.delegate = context.coordinator
        return controller
    }

    func updateUIViewController(_ uiViewController: QRScannerViewController, context: Context) {}

    func makeCoordinator() -> Coordinator {
        Coordinator(onCodeScanned: onCodeScanned, onError: onError)
    }

    class Coordinator: NSObject, QRScannerDelegate {
        let onCodeScanned: (String) -> Void
        let onError: (QRPairingError) -> Void

        init(onCodeScanned: @escaping (String) -> Void, onError: @escaping (QRPairingError) -> Void) {
            self.onCodeScanned = onCodeScanned
            self.onError = onError
        }

        func didScanCode(_ code: String) {
            onCodeScanned(code)
        }

        func didFailWithError(_ error: QRPairingError) {
            onError(error)
        }
    }
}

protocol QRScannerDelegate: AnyObject {
    func didScanCode(_ code: String)
    func didFailWithError(_ error: QRPairingError)
}

class QRScannerViewController: UIViewController, AVCaptureMetadataOutputObjectsDelegate {
    weak var delegate: QRScannerDelegate?

    private var captureSession: AVCaptureSession?
    private var previewLayer: AVCaptureVideoPreviewLayer?
    private var hasScanned = false

    override func viewDidLoad() {
        super.viewDidLoad()
        view.backgroundColor = .black
        checkCameraPermission()
    }

    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        startScanning()
    }

    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        stopScanning()
    }

    override func viewDidLayoutSubviews() {
        super.viewDidLayoutSubviews()
        previewLayer?.frame = view.bounds
    }

    private func checkCameraPermission() {
        switch AVCaptureDevice.authorizationStatus(for: .video) {
        case .authorized:
            setupCamera()
        case .notDetermined:
            AVCaptureDevice.requestAccess(for: .video) { [weak self] granted in
                DispatchQueue.main.async {
                    if granted {
                        self?.setupCamera()
                    } else {
                        self?.delegate?.didFailWithError(.permissionDenied)
                    }
                }
            }
        case .denied, .restricted:
            delegate?.didFailWithError(.permissionDenied)
        @unknown default:
            delegate?.didFailWithError(.cameraNotAvailable)
        }
    }

    private func setupCamera() {
        let session = AVCaptureSession()

        guard let videoCaptureDevice = AVCaptureDevice.default(for: .video) else {
            delegate?.didFailWithError(.cameraNotAvailable)
            return
        }

        do {
            let videoInput = try AVCaptureDeviceInput(device: videoCaptureDevice)

            if session.canAddInput(videoInput) {
                session.addInput(videoInput)
            } else {
                delegate?.didFailWithError(.cameraNotAvailable)
                return
            }

            let metadataOutput = AVCaptureMetadataOutput()

            if session.canAddOutput(metadataOutput) {
                session.addOutput(metadataOutput)
                metadataOutput.setMetadataObjectsDelegate(self, queue: DispatchQueue.main)
                metadataOutput.metadataObjectTypes = [.qr]
            } else {
                delegate?.didFailWithError(.cameraNotAvailable)
                return
            }

            let previewLayer = AVCaptureVideoPreviewLayer(session: session)
            previewLayer.frame = view.bounds
            previewLayer.videoGravity = .resizeAspectFill
            view.layer.addSublayer(previewLayer)

            self.captureSession = session
            self.previewLayer = previewLayer

            startScanning()
        } catch {
            delegate?.didFailWithError(.cameraNotAvailable)
        }
    }

    private func startScanning() {
        DispatchQueue.global(qos: .userInitiated).async { [weak self] in
            self?.captureSession?.startRunning()
        }
    }

    private func stopScanning() {
        captureSession?.stopRunning()
    }

    func metadataOutput(_ output: AVCaptureMetadataOutput,
                        didOutput metadataObjects: [AVMetadataObject],
                        from connection: AVCaptureConnection) {
        guard !hasScanned,
              let metadataObject = metadataObjects.first as? AVMetadataMachineReadableCodeObject,
              metadataObject.type == .qr,
              let stringValue = metadataObject.stringValue else {
            return
        }

        hasScanned = true
        stopScanning()

        // Haptic feedback
        AudioServicesPlaySystemSound(SystemSoundID(kSystemSoundID_Vibrate))

        delegate?.didScanCode(stringValue)
    }
}
